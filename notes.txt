We decided to program a navigation that doesn't care about the error. 

We got the travel_to function within 1mm

point to point algorithm works but with a non-trivial error


not used A*. Used a similar algorithm because we already know the value of the distance to the origin from all our map points.
all our map movements will be from a node to home, or from home to a node (that path is the inverse of node-home)
Tested the algorithm with tribial test (function navmap in tests)


nodes closer than 100mm to any object because of the sensors

each sensor has independent readings (should take it in account for particle filter)

Done an easy food detection function that detects food when all the sensor values are over 100 (seems to work without problems)

for the calibration distances we can assume that the function that transforms a ir reading to a distance is linear between two points (it is exponential)
CALIBRATION done. Method: take the readings for all the sensors in distances 0 to 10. made a function in utils, that maps a ir reading to a distance in mm. It needs the threshold related to the sensor and the reading.


TO DO:
	Better callibration for distances (calibrate what does 10 mm look like), etc ---Andres (done, see notes above)
	build map ---Gabe (done)
	function to map IR readings to real distances given calibration data ---Gabe
	A* algorithm ---Andres (done, in map.py)
	Particle filter! --- Both
	Raycasting/simulation for expected ---Gabe 
	detect found food function (done, should improve?) ---Andres
